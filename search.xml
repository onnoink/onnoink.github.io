<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP头中的Trailer到底是干啥用的</title>
      <link href="/2021/11/02/HTTP%E5%A4%B4%E4%B8%AD%E7%9A%84Trailer%E5%88%B0%E5%BA%95%E6%98%AF%E5%B9%B2%E5%95%A5%E7%94%A8%E7%9A%84/"/>
      <url>/2021/11/02/HTTP%E5%A4%B4%E4%B8%AD%E7%9A%84Trailer%E5%88%B0%E5%BA%95%E6%98%AF%E5%B9%B2%E5%95%A5%E7%94%A8%E7%9A%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>这一次认真了解一下Cookie</title>
      <link href="/2021/10/22/%E8%BF%99%E4%B8%80%E6%AC%A1%E8%AE%A4%E7%9C%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BCookie/"/>
      <url>/2021/10/22/%E8%BF%99%E4%B8%80%E6%AC%A1%E8%AE%A4%E7%9C%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BCookie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>异或操作的解析</title>
      <link href="/2021/10/20/%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/10/20/%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>平时提到 <code>2 ^ 3</code> 之类的操作，我们很容易联想到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0010</span><br><span class="line">0000 0011 (xor)</span><br><span class="line">---------------</span><br><span class="line">0000 0001</span><br></pre></td></tr></table></figure><p>最后得到的结果是<code>1</code></p><p>但是如果是<code>2 ^ -3</code> 那结果是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0000 0011 (原码)</span><br><span class="line">1000 0010 (原码)</span><br><span class="line"></span><br><span class="line">变为</span><br><span class="line"></span><br><span class="line">0000 0011 (补码)</span><br><span class="line">1111 1110 (补码) (xor)</span><br><span class="line">-----------------</span><br><span class="line">1111 1101 (补码)  </span><br><span class="line"></span><br><span class="line">变为</span><br><span class="line"></span><br><span class="line">1000 0011 (原码)</span><br><span class="line"></span><br><span class="line">最后得到结果是-3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>504Gateway-Timeout啥情况</title>
      <link href="/2021/10/19/504Gateway-Timeout%E5%95%A5%E6%83%85%E5%86%B5/"/>
      <url>/2021/10/19/504Gateway-Timeout%E5%95%A5%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言Slice详解</title>
      <link href="/2021/10/14/Go%E8%AF%AD%E8%A8%80Slice%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/10/14/Go%E8%AF%AD%E8%A8%80Slice%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法训练营-430扁平化多级双向链表</title>
      <link href="/2021/10/02/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-430%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/10/02/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-430%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/</a></p></blockquote><h1 id="首次练习"><a href="#首次练习" class="headerlink" title="首次练习"></a>首次练习</h1><blockquote><p>2021-09-24</p></blockquote><p>首次没有完美解决，只有一个大概思路，但是没有正确解决，查看解析后解决，记录大概思路<br>这题使用递归的方式进行解决，从跟节点开始遍历每个节点，如果改节点包含子级节点，则递归遍历该节点的子节点。并将改节点的Next节点和子级别节点的最后一个节点关联在一起，直到当前级别节点遍历完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func flatten(root *Node) *Node &#123;</span><br><span class="line">    ft(root)</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func ft(node *Node) (last *Node) &#123;</span><br><span class="line">    cur := node </span><br><span class="line">    for cur != nil &#123;</span><br><span class="line">        // 为了遍历，当前级别节点，每次要把当前级别节点记下来，防止当前节点的Next指向Child的时候，Next信息丢失</span><br><span class="line">        next := cur.Next</span><br><span class="line">        // 如果当前节点包含子级链表的头节点，就遍历当前节点的子级链表</span><br><span class="line">        if cur.Child != nil &#123;</span><br><span class="line">            // 其实也是递归执行这个函数，考虑一种最简单的，二级切只有一个节点包含Child的情况，扁平化的最简单的就是用当前节点Child替换Next，然后子链表的Last指向当前节点的之前的Next，之前的Next指向子链表的Last。类似双向链表插入数据一样,对于多级，多个节点包含的情况实际是一样的，递归的情况下，永远是倒数第二和第一级别的合并，就是最简单的情况，当倒数第二和第一级别合并之后，倒数第三级别和倒数第二级别也就变成了最简单的情况</span><br><span class="line">            childLast := ft(cur.Child)</span><br><span class="line"></span><br><span class="line">            cur.Next = cur.Child</span><br><span class="line">            cur.Child.Prev = cur</span><br><span class="line">            cur.Child = nil</span><br><span class="line"></span><br><span class="line">            if next != nil &#123;</span><br><span class="line">                childLast.Next = next</span><br><span class="line">                next.Prev = childLast</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 这里需要理解一下，最简单情况下，当前最后一个其实就是子级链表的最后一个</span><br><span class="line">            last = childLast</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            last = cur</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第二次练习"><a href="#第二次练习" class="headerlink" title="第二次练习"></a>第二次练习</h1><blockquote><p>2021-09-25</p></blockquote><h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>时隔一天，还是很清楚的</p><h1 id="第三次练习"><a href="#第三次练习" class="headerlink" title="第三次练习"></a>第三次练习</h1><blockquote><p>2021-10-02</p></blockquote><h3 id="反馈-1"><a href="#反馈-1" class="headerlink" title="反馈"></a>反馈</h3><p>主要要明白从倒数第一级别和倒数第二级别开始合并，每次只考虑两级的合并即可，不要想象的太复杂！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的SortedSet底层结构剖析</title>
      <link href="/2021/09/28/Redis%E7%9A%84SortedSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/"/>
      <url>/2021/09/28/Redis%E7%9A%84SortedSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="悲催时刻"><a href="#悲催时刻" class="headerlink" title="悲催时刻"></a>悲催时刻</h1><p>又又又去面试了，面试官问了一个有序集合底层的数据结构是什么？我想可能很多没有细致了解Redis源码的同学听的最多的就是<code>跳表</code>这个数据结构了，所以我脱口而出跳表，然后面试官很坏，他问了一个给我说一下<code>ZSCORE</code>的时间复杂度，我就在心里默默的计算，岂不是<code>O(n)</code>吗？然后面试官笑笑不说话，结果可相知，我又又又挂了。</p><h1 id="亡羊补牢"><a href="#亡羊补牢" class="headerlink" title="亡羊补牢"></a>亡羊补牢</h1><p>然后我当然又去恶补了一下Redis一些基础知识，此时才知道当时的自己多么的浅薄。这次主要说Redis的Sorted Set数据类型，其他的等我下次面试再挂了再来跟大家说吧。</p><h2 id="Redis的基础结构"><a href="#Redis的基础结构" class="headerlink" title="Redis的基础结构"></a>Redis的基础结构</h2><p>Redis是一个键值对数据库，所以Redis数据库底层存储键值对的结构是哈希表，Redis中有一个<code>struct</code>类型是<code>dicht</code>就是一个对hash表的封装，Redis使用一个MurMurHash(我不知道你们怎么记忆，我记忆的方式特恶心，muamuahash亲亲hash)来寻找每个key在哈希表中的位置，然后用链表法解决哈希冲突(顺便说一下，链表法每次都是把新的元素放在开头的位置)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">    // table是一个数组的二级指针，就是每个哈希表结构必备的数组结构</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    // size 是上面那个数组的长度</span><br><span class="line">    unsigned long size;</span><br><span class="line">    // 这个用来算根据hash函数生成的数组在数组索引位置的掩码</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    // 这个表用了多少</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>但是实际Redis中不直接使用dictht这个结构，而是使用了进一步封装的<code>dict</code>这个结构体，用来进行渐进式reshah的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    // 类型，定义了不同类型的不同的一堆构造函数之类的方法，用来对不同的type的hash的value进行操作</span><br><span class="line">    dictType *type;</span><br><span class="line">    // 传给上面方法的参数</span><br><span class="line">    void *privdata;</span><br><span class="line">    // 刚才说的结构体，注意有俩ht[0] 和ht[1]</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    // 进行rehash的时候索引</span><br><span class="line">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line">    // 正在安全运行的迭代器的数量? 这个还在看</span><br><span class="line">    unsigned long iterators; /* number of iterators currently running */</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>上面的ht是一个数组，包含两个哈希表，也就是上面的<code>dicht</code>结构，数组内的元素都是<code>dictEntry</code>,<code>dictEntry</code>包含了<code>key</code>和<code>v</code>两个关键属性，一般情况下他们都是<code>RedisObject</code>结构体，<code>RedisObject</code>用来表示全部的5种数据结构，通过<code>type</code>来进行区分，同时我们知道我们熟知的5个redis数据结构很多都有两个实现的底层数据结构，通过<code>encoding</code>字段来区分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    // 类型 4 位置 在3.0的版本里，包含REDIS_STRING REDIS_LIST REDIS_HASH REDIS_SET REDIS_ZSET</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    // 编码方式 在Redis里，一种类型可能包含多个编码方式，例如Set就是HASH表或者是上面的dict 通过这个encoding来识别不同的编码方式</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    // LRU算法的</span><br><span class="line">    unsigned lru:LRU_BITS; </span><br><span class="line">    // 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line">    // 指向实际的底层结构</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    void *key;</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">        double d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    struct dictEntry *next;    </span><br><span class="line">    void *metadata[];          </span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Sorted-Set的结构"><a href="#Sorted-Set的结构" class="headerlink" title="Sorted Set的结构"></a>Sorted Set的结构</h2><p>说了那么多,和题目也没啥关系啊？其实不是的，在<code>RedisObject</code>中，如果<code>zset</code>的<code>encoding</code>字段表示<code>zset</code>的编码形式是跳表的结构的话，其实对应的redisObject的ptr指向的数据结构是下面这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>是一个哈希表和一个跳表，所以执行<code>zscore</code>的时候不用遍历跳表的<code>level0</code>的全部元素，直接使用hash表进行定位就可以,时间复杂度是<code>O(1)</code></p>]]></content>
      
      
      <categories>
          
          <category> Redis底层结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Int类型的取值范围</title>
      <link href="/2021/09/27/Mysql%E7%9A%84Int%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"/>
      <url>/2021/09/27/Mysql%E7%9A%84Int%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="悲催时刻"><a href="#悲催时刻" class="headerlink" title="悲催时刻"></a>悲催时刻</h1><p>面试的时候，被问到 MySQL Int 类型的取值范围，一开始寻思问的不会是宽度的设置吧，最后真的竟然是问取值范围，MySQL的Int是32位的，那32位的Int类型的取值范围是多少呢？一时间我竟然有些恍惚，每次看到int8的取值范围我们的肌肉记忆就会告诉我们是<code>[-128,127]</code>，但是为啥是这个取值范围呢？我掐指一算，不应该是<code>[-127,127](注意，这个是错误的！！！)</code>吗？<br>第一位是符号位置，所以<code>[0111,1111]</code>是<code>127</code>，<code>[1111,1111]</code>是<code>-127</code>岂不是爽歪歪？结果正确的答案是<code>[-128,127]</code>，我就不知道你怎么给老子存<code>-128</code></p><p>结果可想而知，我又挂了</p><h1 id="亡羊补牢"><a href="#亡羊补牢" class="headerlink" title="亡羊补牢"></a>亡羊补牢</h1><p>为了熟练掌握这个基础知识，我又又又一次开始Google，终于有一定的理解，计算机里带符号类型的整数都是使用一种称为<code>补码</code>的方式存储的，为啥呢？因为CPU内部的哪些乱七八糟的门电路什么的，费老大劲才能组成一个<code>全加器</code>用来对两个数进行加法运算，结果你给老子来个减法？所以为了减少复杂数字电路的设计，复用<code>全加器</code>，出现了<code>原码</code>、<code>反码</code>和<code>补码</code>的概念，要有一个概念就是符号整数在内存里都是补码存储的，便于运算.</p><h2 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h2><p><code>原码</code> 就是我们学习和理解的符号整形的二进制表示方式，例如<code>-3</code>用<code>[1000,0011]</code>表示，<code>+3</code>用<code>[0000,0011]</code>表示</p><p><code>反码</code> 正数的反码和原码一样，负数的反码是<code>符号为不变,其余位取反</code>，所以 <code>+3</code> 的反码还是<code>[0000,0011]</code>，<code>-3</code>的反码是[1111,1100],</p><p><code>补码</code> 正数的补码和原码一样，负数的补码是<code>符号为不变,其余位取反后+1</code>，所以 <code>+3</code> 的补码还是<code>[0000,0011]</code>，<code>-3</code>的补码是[1111,1101]</p><h2 id="CPU-符号整数的加减法的计算"><a href="#CPU-符号整数的加减法的计算" class="headerlink" title="CPU 符号整数的加减法的计算"></a>CPU 符号整数的加减法的计算</h2><p>上面我们说过，为了复用<code>加法器</code>，我们需要把<code>减法</code>干掉，恰好我们有一个定理是<code>1-1 = 1+(-1)</code>，哈哈哈，怎么样，这不就把减法<br>干掉了吗？我们来试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 + (-3) = [0000,0011](原) + [1000,0011](原) = [1000,0110](原) = -6 </span><br></pre></td></tr></table></figure><p>错的离谱，符号为参与运算，错的不能再错了，难道再设计个电路专门处理符号位？这也太蠢了，我们用新技能<code>反码</code>试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 + (-3) = [0000,0011](反) + [1111,1100](反) =  [1111,1111](反) = [1000,0000](原) = -0 </span><br></pre></td></tr></table></figure><p>bingo! 答对了，但是 [1000,0000] 是 <code>-0</code> 难道[0000,0000]是<code>+0</code>吗？<code>+0</code>和<code>-0</code>怕不是不相等吧，所以我们再用另一个新技能<code>补码试试</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 + (-3) = [0000,0011](补) + [1111,1101](补) = &#123;1&#125;[0000,0000](补) = [1000,0000](原) = 0 </span><br></pre></td></tr></table></figure><p><code>补码</code>有点神奇啊，竟然溢出了一个位置，咋办，难不成把前面哪个数据的内存给偷摸的改了? 其实不是，加法器会丢弃溢出的位置，符号为的新值作为符号的判定，所以上面是[0000,0000] 是 0</p><p>这个例子不好，我们换一个再试一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-127 - 1 = (-127) + (-1) = [1000,0001](补) + [1111,1111](补) = &#123;1&#125;[1000,0000](补) = [1000,0000](原) </span><br></pre></td></tr></table></figure><p>点子不好，咋又溢出了，我们把它按照惯丢掉，变成了<code>[1000,0000]</code>，你大爷的，<code>-0</code>你怎么又来了，结果不应该是<code>-128</code>吗，所以大家一生气，让[1000,0000]就代表<code>-128</code>吧，所以在<code>补码</code>表示中[1000,0000]就代表了(-128),原先的<code>-0</code>没了，但是<code>+0</code>还在,所以Int(8)的取值范围就是[1000,0000] 到 [0111,1111] 也就是<code>[-128,127]</code></p><p>上面的都是点子背，我们弄一个正常的来算一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">12 - 9 = [0000,1100](补) + [1111,0111](补) = &#123;1&#125;[0000,0011](补) = [0000,0011](原) = 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也是正确的</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>所以我们得到一个规律，一个符号整数的取值范围和他所占用的位数的n的关系为 <code>[-(2^(n-1)),2^(n-1)-1]</code>, MySQL Int 类型的位数是32位置，所以MySQL Int的取值范围是 <code>[-(2^(32-1)),2^(32-1)-1]</code> 是 <code>[-2 147 483 648,2 147 483 647]</code></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练营 五毒刷题法</title>
      <link href="/2021/09/26/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%20%E4%BA%94%E6%AF%92%E5%88%B7%E9%A2%98%E6%B3%95/"/>
      <url>/2021/09/26/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%20%E4%BA%94%E6%AF%92%E5%88%B7%E9%A2%98%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="悲催进行时"><a href="#悲催进行时" class="headerlink" title="悲催进行时"></a>悲催进行时</h1><p>之前去面试某音乐平台，最后一个算法题，贼简单，链表回文字符串，结果个人因为太紧张，思路阻塞，最终没有做出来，面试也挂了，其实这个题目我做过，而且我还记得思路，快慢指针法，但是实际做的时候，很多边界问题和奇偶问题又让我变得不知所措，所以后来看了算法训练营的大哥的课程，感觉收获颇丰，所以在此记录我的刷题记录和刷题大法。</p><h1 id="精通一门知识的技巧"><a href="#精通一门知识的技巧" class="headerlink" title="精通一门知识的技巧"></a>精通一门知识的技巧</h1><p>授人以鱼，不如授人以渔，这门课的第一个最大的收获是自信，就是其实天才没有那么多，很多算法题你看起来没有任何思路是正常的，大神有时候也是毫无思路，所以不要因为一个题目毫无思路就自我否定觉着自己是不是不适合做一名开发工程师。<br>其次的收获就是精通一门知识的技巧</p><h2 id="Chunk-It-Up"><a href="#Chunk-It-Up" class="headerlink" title="Chunk It Up"></a>Chunk It Up</h2><p>拆分知识点，算法知识浩如烟海，如果零散的学习，不对知识点进行归纳和拆分，最后不能形成解题的套路，那学习带来的成效就不大，所以不单单对算法，对任何一门知识，都应该把他们拆分成小的知识点，然后攻克这些小的知识点，最后连点成线，全面掌握一门知识。</p><h2 id="Deliberate-Practcing"><a href="#Deliberate-Practcing" class="headerlink" title="Deliberate Practcing"></a>Deliberate Practcing</h2><p>刻意练习，前面说面试的时候，明明做过的题，结果没有做出来，其实就是因为当时做了一次之后，只记了一个大概的解题方式，没有了解每一步的细节的处理，也就是所谓的眼高手低，最终没能做出这道题目。所以扎实才是算法攻克的最佳实践，刻意练习是扎实掌握算法解题细节的不二法门，所谓刻意练习，老师总结一个五毒刷题法，我自己修改理解后整理为，对每一道题，至少要进行5遍的刻意练习，而且根据遗忘曲线，五遍练习需要分散在人类遗忘曲线的关键点上，我借助一些手机上遗忘曲线的APP，对每一道我做过的题目进行管理，分为首次练习、次日、一周后、一个月后、90天后进行题目的刻意训练。通过多次的刻意训练，真正掌握解题思路和方法。</p><h2 id="FeedBack"><a href="#FeedBack" class="headerlink" title="FeedBack"></a>FeedBack</h2><p>反馈，这个是我觉着最重要的一点，也是解题思路和套路形成的最关键的点，有些题目可能大家看了答案能够在当时机械化的翻译写出答案，但是实际上没有理解这个题目的实际意义，所以通过查看解答，获取的反馈尤其重要，除了了解怎么做，更重要的是了解为什么这样做。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>接下来会把践行的过程也同步的发出来，写字太麻烦了啊啊啊</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 学习方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诫勉</title>
      <link href="/2021/09/26/%E8%AF%AB%E5%8B%89/"/>
      <url>/2021/09/26/%E8%AF%AB%E5%8B%89/</url>
      
        <content type="html"><![CDATA[<p>断断续续用Hexo + Github Pages 功能搭建了N次这个博客了，每次都是无疾而终，希望这次的能持续的坚持下去</p><p>没有坚持下去的原因一般是因为没有一个明确的目标和与之匹配的规划，下一步就是要做一个具体的博客涉及内容的规划，初步设想会包括<code>数据结构和算法</code>,<code>MySQL</code>,<code>Redis</code>,<code>Golang</code>几个方向的内容，主要来源是日常学习和工作中设计的知识点。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
